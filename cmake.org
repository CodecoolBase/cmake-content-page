#+TITLE: CMake
#+OPTIONS: toc:nil num:nil

CMake is the build tool used in a lot of C/C++ projects nowadays.
We've been using it too for the last couple of weeks.

But we mostly used it as a magic black box so far.

- What is the exact problem it is trying to solve?
- How is it solving it?
- What is exactly that is done by CMake and not delegated to other tools?

These are the questions this page aims to answer.

* The problem at hand

In this tutorial we'll work from the shell so we have control over what is executed.
And also can inspect things between steps.
Let's create a directory to work in and enter it:

#+BEGIN_SRC sh
  $ mkdir cmake-tutorial
  $ cd cmake-tutorial
#+END_SRC

Let's create a C++ file called *max.cpp*

#+BEGIN_SRC c++ :tangle max.cpp :padline no
  namespace cmake_tutorial {
  int max(int a, int b) {
    if (a > b)
      return a;
    return b;
  }
  }
#+END_SRC

Also create a header file *max.hpp* so we can refer to our function from other files.

#+BEGIN_SRC c++ :tangle max.hpp :padline no
  #pragma once

  namespace cmake_tutorial {
  int max(int, int);
  }
#+END_SRC

And finally create a main file from where we can use it.

*main.cpp:*
#+BEGIN_SRC c++
  #include <iostream>

  #include "max.hpp"

  int main() {
    std::cout << "The maximum of 2 and 4 is: " << cmake_tutorial::max(2, 4)
              << std::endl;
    return 0;
  }
#+END_SRC

Now the fun part: Let's create a runnable program.

#+BEGIN_SRC sh
  $ clang++ --std=c++11 max.cpp main.cpp -o main

  $ ./main
  The maximum of 2 and 4 is: 4
#+END_SRC

Whoohoo!! Easy-peasy.

It took some arguments but nothing complicated.
Let's say we want to use variables for the numbers so we can change them consistently.
The new *main.cpp* looks like this:

#+BEGIN_SRC c++ :tangle main.cpp :padline no
  #include <iostream>

  #include "max.hpp"

  int main() {
    constexpr int a = 2;
    constexpr int b = 4;

    std::cout << "The maximum of " << a << " and " << b
              << " is: " << cmake_tutorial::max(a, b) << std::endl;
    return 0;
  }
#+END_SRC

Everything works just as before:

#+BEGIN_SRC sh
  $ clang++ --std=c++11 max.cpp main.cpp -o main

  $ ./main
  The maximum of 2 and 4 is: 4
#+END_SRC

*But wait!*

Now we are recompiling *max.cpp* as well.
Even though it didn't change at all.

This is not much of a problem now but we can see
how it could be a huge issue in a real project with lots of files.

What can we do?
- Keep around intermediate files.
- Recompile what's changed.
- Link the intermediates into an executable.

#+BEGIN_SRC sh
  $ for source in *.cpp; do clang++ --std=c++11 -c $source; done

  $ clang++ *.o -o main

  $ ./main
  The maximum of 2 and 4 is: 4
#+END_SRC

With the =-c= argument we managed to generate so called *object files*:

#+BEGIN_SRC sh
  $ size *.o
     text    data     bss     dec     hex filename
      365       8       1     374     176 main.o
       56       0       0      56      38 max.o
#+END_SRC

And used those instead of the =.cpp= files to link our executable.

Now we have another problem:
- We have to do more steps then before.
- We have to keep track of what has changed.

One solutions to these problems is older than the internet:

* Makefiles

Makefiles contain rules.
Rules (in general) have three parts:
- A target to make
- Dependencies needed to make the target
- List of steps to make the target from its dependencies

Rules have the following form:
#+BEGIN_SRC makefile
  target: dependency1 dependency2 dependency3
          cmd -o target dependency1 dependency2 dependency3
          echo building target done
#+END_SRC

~NOTE:~ steps are indented with a ~TAB~ character

To make writing rules less tedious and errorprone there are some special variables.
For example:
- =$@= is for the target
- =$<= is the first dependency
- =$^= is all the dependencies

Also to execute steps silently they can be prefixed with an =@= sign.

So the above rule can be rewritten like this:

#+BEGIN_SRC makefile
  target: dependency1 dependency2 dependency3
          @cmd -o $@ $^
          @echo building target done
#+END_SRC

Variables can also be introduced and used with the following syntax:

#+BEGIN_SRC makefile
  TARGET=target
  DEPENDENCIES=dependency1\
    dependency2\
    dependency3

  $(TARGET): $(DEPENDENCIES)
          @cmd -o $@ $^
          @echo building $(TARGET) done
#+END_SRC

~NOTE:~ variables with names longer than one letter have to be inside parenthesis

Based on this we can write our own makefile:

*Makefile*
#+BEGIN_SRC makefile
  CXX=clang++
  CXX_FLAGS=--std=c++11
  OBJECTS=main.o\
    max.o

  main.o: main.cpp
          @$(CXX) $(CXX_FLAGS) -c $<
          @echo COMPILE $<

  max.o: max.cpp
          @$(CXX) $(CXX_FLAGS) -c $<
          @echo COMPILE $<

  main: $(OBJECTS)
          @$(CXX) $^ -o $@
          @echo LINK $@
#+END_SRC

Let's try it:

#+BEGIN_SRC sh
  $ make main
  COMPILE main.cpp
  COMPILE max.cpp
  LINK main

  $ touch max.cpp

  $ make main
  COMPILE max.cpp
  LINK main

  $ make main
  make: 'main' is up to date.
#+END_SRC

Notice how when we update the timestamp of *max.cpp* then only *max.o* and *main* is rebuilt.
Make can figure out what needs to be rebuilt based on file timestamps.

This is pretty cool, but the rule for the object files is the same to the letter.
One more convenience is that we can make general rules based on file extension.
We had to add the extension to =.SUFFIXES= which is a special target in a Makefile.
Then we can add rules for making =.ext1= files out of =.ext2= files as the following:

#+BEGIN_SRC makefile
  .SUFFIXES: .ext1 .ext2

  .ext2.ext1:
          @cmd -o $@ $<
          @echo BUILD $@
#+END_SRC

Let's do that:

#+BEGIN_SRC makefile :tangle Makefile :padline no
  CXX=clang++
  CXX_FLAGS=--std=c++11
  OBJECTS=main.o\
    max.o

  .SUFFIXES: .cpp .o

  .cpp.o:
          @$(CXX) $(CXX_FLAGS) -c $<
          @echo COMPILE $<

  main: $(OBJECTS)
          @$(CXX) $^ -o $@
          @echo LINK $@
#+END_SRC
